<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SYSG: Mesh Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SYSG
   </div>
   <div id="projectbrief">Resuelve problemas usando el CVFEM</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_mesh-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Mesh Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Los objetos tipos mesh son contenedores para el dominio de interes generado con la herramienta gmsh.  
 <a href="class_mesh.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_mesh_8hpp_source.html">Mesh.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2af137f1571af89172b9c102302c416b"><td class="memItemLeft" align="right" valign="top"><a id="a2af137f1571af89172b9c102302c416b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh.html#a2af137f1571af89172b9c102302c416b">Mesh</a> ()</td></tr>
<tr class="memdesc:a2af137f1571af89172b9c102302c416b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor vacio, inicializa los atributos a valores por defecto. <br /></td></tr>
<tr class="separator:a2af137f1571af89172b9c102302c416b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54a9cf0f6223e63253c8e9f8f99746b3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh.html#a54a9cf0f6223e63253c8e9f8f99746b3">Mesh</a> (std::string filename, std::vector&lt; double &gt; &amp;vertices)</td></tr>
<tr class="memdesc:a54a9cf0f6223e63253c8e9f8f99746b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor para cargar un archivo &lt;nombre&gt;.msh y encargado de llamar a initialize(filename), para dar el tratamiento basico a una geometria obtenida con la herramienta gmsh.  <a href="#a54a9cf0f6223e63253c8e9f8f99746b3">More...</a><br /></td></tr>
<tr class="separator:a54a9cf0f6223e63253c8e9f8f99746b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa6559daf1f8495fd0a796fb31370542"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh.html#afa6559daf1f8495fd0a796fb31370542">initialize</a> (std::string filename, std::vector&lt; double &gt; &amp;vertices)</td></tr>
<tr class="separator:afa6559daf1f8495fd0a796fb31370542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0885d845bc4001d43d7d92a0a98a127a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh.html#a0885d845bc4001d43d7d92a0a98a127a">readFileGMSH</a> (std::string filename, std::vector&lt; std::vector&lt; double &gt;&gt; &amp;coord, std::vector&lt; std::vector&lt; int &gt;&gt; &amp;elemn)</td></tr>
<tr class="memdesc:a0885d845bc4001d43d7d92a0a98a127a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lee un archivo *.msh generado con la herramienta gmsh y almacena las coordenadas y los elementos triangulares que lo conforman.  <a href="#a0885d845bc4001d43d7d92a0a98a127a">More...</a><br /></td></tr>
<tr class="separator:a0885d845bc4001d43d7d92a0a98a127a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a49aea1d3aa8ccf4f8acd367906b4ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh.html#a1a49aea1d3aa8ccf4f8acd367906b4ab">reorderNode</a> (std::vector&lt; std::vector&lt; double &gt;&gt; &amp;coord)</td></tr>
<tr class="memdesc:a1a49aea1d3aa8ccf4f8acd367906b4ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toma los nodos leidos del archivo y cambia el orden dado por GMSH, ordena primero con respecto a Y y despues con respecto a X de forma tal que se tendra todos los nodos con la misma componente en Y y despues se ordena las x en forma asecendente.  <a href="#a1a49aea1d3aa8ccf4f8acd367906b4ab">More...</a><br /></td></tr>
<tr class="separator:a1a49aea1d3aa8ccf4f8acd367906b4ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88e3d635b654e3122774b3e49770648e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh.html#a88e3d635b654e3122774b3e49770648e">relationNodes</a> (std::vector&lt; std::vector&lt; double &gt;&gt; &amp;coord, std::vector&lt; int &gt; &amp;relation)</td></tr>
<tr class="memdesc:a88e3d635b654e3122774b3e49770648e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toma los nodos ordenados y los desordenados y devuelve una relacion entre ellos, donde el indice de relation se refiere a la numeración de gmsh y el contenido indica a que lugar se movio en los nodos.  <a href="#a88e3d635b654e3122774b3e49770648e">More...</a><br /></td></tr>
<tr class="separator:a88e3d635b654e3122774b3e49770648e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7972a36435ea43732b4611a3765c28f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh.html#a7972a36435ea43732b4611a3765c28f6">reorderElement</a> (std::vector&lt; std::vector&lt; int &gt;&gt; &amp;elemn, std::vector&lt; int &gt; &amp;relation)</td></tr>
<tr class="memdesc:a7972a36435ea43732b4611a3765c28f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Se reordenan los elementos segun la nueva numeracion de los nodos.  <a href="#a7972a36435ea43732b4611a3765c28f6">More...</a><br /></td></tr>
<tr class="separator:a7972a36435ea43732b4611a3765c28f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8da1c7918301eaf9f6c71979247d2d94"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh.html#a8da1c7918301eaf9f6c71979247d2d94">borderInteriorNode</a> (std::vector&lt; double &gt; &amp;vertices)</td></tr>
<tr class="memdesc:a8da1c7918301eaf9f6c71979247d2d94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Para un dominio rectangular determina que nodos se encuentran sobre la frontera, cuales son interiores y los almacena.  <a href="#a8da1c7918301eaf9f6c71979247d2d94">More...</a><br /></td></tr>
<tr class="separator:a8da1c7918301eaf9f6c71979247d2d94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe2ade2afc588a69ae7793eac37babfe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh.html#abe2ade2afc588a69ae7793eac37babfe">bondaryCondition</a> (int <a class="el" href="class_mesh.html#aef283d305e17ab48771999e7835ed294">type</a>, double <a class="el" href="class_mesh.html#adef108df36f29f4880a9233075e04210">value</a>)</td></tr>
<tr class="memdesc:abe2ade2afc588a69ae7793eac37babfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Para cada nodo de frontera se almacena en memoria el tipo de condición de frontera y su valor, solo acepta dos tipos distintos de condiciones de frontera Dirchelet y Neumman.  <a href="#abe2ade2afc588a69ae7793eac37babfe">More...</a><br /></td></tr>
<tr class="separator:abe2ade2afc588a69ae7793eac37babfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e306db2532f24a66b8d43cb634afd61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh.html#a1e306db2532f24a66b8d43cb634afd61">typeNodeBorder</a> ()</td></tr>
<tr class="memdesc:a1e306db2532f24a66b8d43cb634afd61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distingue los nodos de frontera en nodos tipo Dirichlet y nodos tipo Neumann.  <a href="#a1e306db2532f24a66b8d43cb634afd61">More...</a><br /></td></tr>
<tr class="separator:a1e306db2532f24a66b8d43cb634afd61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71e8935f4fb4b98e12aefb137ab15131"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh.html#a71e8935f4fb4b98e12aefb137ab15131">areaElement</a> ()</td></tr>
<tr class="memdesc:a71e8935f4fb4b98e12aefb137ab15131"><td class="mdescLeft">&#160;</td><td class="mdescRight">Para cada elemento triangular almacenado calcula su área según las coordenadas de sus vertices usando un determinantes, ésta área es almacenada en memoria para su uso.  <a href="#a71e8935f4fb4b98e12aefb137ab15131">More...</a><br /></td></tr>
<tr class="separator:a71e8935f4fb4b98e12aefb137ab15131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a721990c561955657b21953ea704e4e6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh.html#a721990c561955657b21953ea704e4e6d">elementSupportNode</a> ()</td></tr>
<tr class="memdesc:a721990c561955657b21953ea704e4e6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Para cada nodo de la malla se calcula sus elementos soporte; es decir se almacena para cada nodo los elementos en donde aparace.  <a href="#a721990c561955657b21953ea704e4e6d">More...</a><br /></td></tr>
<tr class="separator:a721990c561955657b21953ea704e4e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f8707ebeb80eeca1d41ea67a56f7205"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh.html#a9f8707ebeb80eeca1d41ea67a56f7205">nodeNeighborh</a> (int node)</td></tr>
<tr class="memdesc:a9f8707ebeb80eeca1d41ea67a56f7205"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dado un nodo devuelve los nodos más proximos a el que lo rodean es decir sus nodos vecinos.  <a href="#a9f8707ebeb80eeca1d41ea67a56f7205">More...</a><br /></td></tr>
<tr class="separator:a9f8707ebeb80eeca1d41ea67a56f7205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0acd89c6420f7edc3c8ee8169662b67b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh.html#a0acd89c6420f7edc3c8ee8169662b67b">nodeIncongnite</a> ()</td></tr>
<tr class="memdesc:a0acd89c6420f7edc3c8ee8169662b67b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Segun el tipo de cada nodo se determina que nodos son incognita y para que nodos se conoce la solución en ese punto, y son almacenados en memoria.  <a href="#a0acd89c6420f7edc3c8ee8169662b67b">More...</a><br /></td></tr>
<tr class="separator:a0acd89c6420f7edc3c8ee8169662b67b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab798a46d1133887500152df4dfe40736"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh.html#ab798a46d1133887500152df4dfe40736">piP</a> (std::vector&lt; std::pair&lt; double, double &gt;&gt; &amp;vertices)</td></tr>
<tr class="memdesc:ab798a46d1133887500152df4dfe40736"><td class="mdescLeft">&#160;</td><td class="mdescRight">Se implementa el algoritmo PointInPolygon, el cual determina para un poligono convexo si un punto se encuentra en su interior o en su exterior.  <a href="#ab798a46d1133887500152df4dfe40736">More...</a><br /></td></tr>
<tr class="separator:ab798a46d1133887500152df4dfe40736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53a4d94cd56d2cb6439519645269d380"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh.html#a53a4d94cd56d2cb6439519645269d380">nNodeIncongnite</a> ()</td></tr>
<tr class="memdesc:a53a4d94cd56d2cb6439519645269d380"><td class="mdescLeft">&#160;</td><td class="mdescRight">Devuelve el numero de nodos incognta que se tienen en la malla.  <a href="#a53a4d94cd56d2cb6439519645269d380">More...</a><br /></td></tr>
<tr class="separator:a53a4d94cd56d2cb6439519645269d380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7860c41775b643917ea5e8d763ba0505"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh.html#a7860c41775b643917ea5e8d763ba0505">bordeNode</a> ()</td></tr>
<tr class="memdesc:a7860c41775b643917ea5e8d763ba0505"><td class="mdescLeft">&#160;</td><td class="mdescRight">Devuelve un vector con los nodos de frontera.  <a href="#a7860c41775b643917ea5e8d763ba0505">More...</a><br /></td></tr>
<tr class="separator:a7860c41775b643917ea5e8d763ba0505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fcfd56c6f730879f51ff07153091f91"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh.html#a7fcfd56c6f730879f51ff07153091f91">coordX</a> (int node)</td></tr>
<tr class="memdesc:a7fcfd56c6f730879f51ff07153091f91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dado un nodo cualquiera de la malla devuelve su coordenada en x.  <a href="#a7fcfd56c6f730879f51ff07153091f91">More...</a><br /></td></tr>
<tr class="separator:a7fcfd56c6f730879f51ff07153091f91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4f621b62849423e299f681acb4e253c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh.html#af4f621b62849423e299f681acb4e253c">coordY</a> (int node)</td></tr>
<tr class="memdesc:af4f621b62849423e299f681acb4e253c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dado un nodo cualquiera de la malla devuelve su coordenada en y.  <a href="#af4f621b62849423e299f681acb4e253c">More...</a><br /></td></tr>
<tr class="separator:af4f621b62849423e299f681acb4e253c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adef108df36f29f4880a9233075e04210"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh.html#adef108df36f29f4880a9233075e04210">value</a> (int node)</td></tr>
<tr class="memdesc:adef108df36f29f4880a9233075e04210"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dado un nodo frontera devuelve su valor.  <a href="#adef108df36f29f4880a9233075e04210">More...</a><br /></td></tr>
<tr class="separator:adef108df36f29f4880a9233075e04210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef283d305e17ab48771999e7835ed294"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh.html#aef283d305e17ab48771999e7835ed294">type</a> (int node)</td></tr>
<tr class="memdesc:aef283d305e17ab48771999e7835ed294"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dado un nodo frontera devuelve su tipo.  <a href="#aef283d305e17ab48771999e7835ed294">More...</a><br /></td></tr>
<tr class="separator:aef283d305e17ab48771999e7835ed294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add85351d5f09484fa3b4dd43d1043ae9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh.html#add85351d5f09484fa3b4dd43d1043ae9">Incognite</a> ()</td></tr>
<tr class="memdesc:add85351d5f09484fa3b4dd43d1043ae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Devuelve los nodos incognita.  <a href="#add85351d5f09484fa3b4dd43d1043ae9">More...</a><br /></td></tr>
<tr class="separator:add85351d5f09484fa3b4dd43d1043ae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc68a06825b9554803c18248501338c7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh.html#abc68a06825b9554803c18248501338c7">nNode</a> ()</td></tr>
<tr class="memdesc:abc68a06825b9554803c18248501338c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Devuelve el numero total de nodos de una malla.  <a href="#abc68a06825b9554803c18248501338c7">More...</a><br /></td></tr>
<tr class="separator:abc68a06825b9554803c18248501338c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab390b1e1292e0236b1a3d35c6b738228"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh.html#ab390b1e1292e0236b1a3d35c6b738228">showGmsh</a> (std::vector&lt; std::vector&lt; double &gt;&gt; &amp;coord, std::vector&lt; std::vector&lt; int &gt;&gt; &amp;elemn)</td></tr>
<tr class="memdesc:ab390b1e1292e0236b1a3d35c6b738228"><td class="mdescLeft">&#160;</td><td class="mdescRight">Muestra en pantalla los nodos y los elementos leidos del archivo gmsh segun la numeracion por defecto.  <a href="#ab390b1e1292e0236b1a3d35c6b738228">More...</a><br /></td></tr>
<tr class="separator:ab390b1e1292e0236b1a3d35c6b738228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5eb1247da3ed432323f1dd8aebbf554"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh.html#ac5eb1247da3ed432323f1dd8aebbf554">showNode</a> ()</td></tr>
<tr class="memdesc:ac5eb1247da3ed432323f1dd8aebbf554"><td class="mdescLeft">&#160;</td><td class="mdescRight">Muestra en pantalla los nodos con sus coordenadas ordenados.  <a href="#ac5eb1247da3ed432323f1dd8aebbf554">More...</a><br /></td></tr>
<tr class="separator:ac5eb1247da3ed432323f1dd8aebbf554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d528aac55b1e4c2a6f5049f9d2cf90d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh.html#a0d528aac55b1e4c2a6f5049f9d2cf90d">showElement</a> ()</td></tr>
<tr class="memdesc:a0d528aac55b1e4c2a6f5049f9d2cf90d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Muestra en pantalla la nueva composición de los elementos según la nueva numeración.  <a href="#a0d528aac55b1e4c2a6f5049f9d2cf90d">More...</a><br /></td></tr>
<tr class="separator:a0d528aac55b1e4c2a6f5049f9d2cf90d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8d60f17c950dca8ef1a6288860bd3cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh.html#ac8d60f17c950dca8ef1a6288860bd3cb">showNodeElement</a> ()</td></tr>
<tr class="memdesc:ac8d60f17c950dca8ef1a6288860bd3cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Muestra en pantalla la cantidad de nodos y elementos totales de la malla.  <a href="#ac8d60f17c950dca8ef1a6288860bd3cb">More...</a><br /></td></tr>
<tr class="separator:ac8d60f17c950dca8ef1a6288860bd3cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90fd6f1f7a64ff29d1eeee72c22142d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh.html#a90fd6f1f7a64ff29d1eeee72c22142d2">showRelation</a> (std::vector&lt; int &gt; &amp;relation)</td></tr>
<tr class="memdesc:a90fd6f1f7a64ff29d1eeee72c22142d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mostramos en pantalla la relacion de la numeración ordenada con la numeración de gmsh.  <a href="#a90fd6f1f7a64ff29d1eeee72c22142d2">More...</a><br /></td></tr>
<tr class="separator:a90fd6f1f7a64ff29d1eeee72c22142d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de5c225341eb4fc73810d1415eb57da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh.html#a4de5c225341eb4fc73810d1415eb57da">showNodeIF</a> ()</td></tr>
<tr class="memdesc:a4de5c225341eb4fc73810d1415eb57da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Muestra en pantalla que nodos son interiores y que nodos son frontera.  <a href="#a4de5c225341eb4fc73810d1415eb57da">More...</a><br /></td></tr>
<tr class="separator:a4de5c225341eb4fc73810d1415eb57da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a759b0e82f01de4d168b2a30e5280df3c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh.html#a759b0e82f01de4d168b2a30e5280df3c">showArea</a> ()</td></tr>
<tr class="memdesc:a759b0e82f01de4d168b2a30e5280df3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Muestra en pantalla el area de cada elemento triangular que fue calculado.  <a href="#a759b0e82f01de4d168b2a30e5280df3c">More...</a><br /></td></tr>
<tr class="separator:a759b0e82f01de4d168b2a30e5280df3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a895299dd6c9c2e2ffb5ef59becc81fd3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh.html#a895299dd6c9c2e2ffb5ef59becc81fd3">showElementSupportNode</a> ()</td></tr>
<tr class="memdesc:a895299dd6c9c2e2ffb5ef59becc81fd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mostramos en pantalla los elementos soporte de cada nodo.  <a href="#a895299dd6c9c2e2ffb5ef59becc81fd3">More...</a><br /></td></tr>
<tr class="separator:a895299dd6c9c2e2ffb5ef59becc81fd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45a42ffc6565851e50e47b6b618c22f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh.html#a45a42ffc6565851e50e47b6b618c22f5">showBoundaryCondition</a> ()</td></tr>
<tr class="memdesc:a45a42ffc6565851e50e47b6b618c22f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Muestra en pantalla los nodos frontera con su valor asignado y de que tipo son.  <a href="#a45a42ffc6565851e50e47b6b618c22f5">More...</a><br /></td></tr>
<tr class="separator:a45a42ffc6565851e50e47b6b618c22f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01bf98587a47624696aa808efac92ad8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh.html#a01bf98587a47624696aa808efac92ad8">shownodeDirichlet</a> ()</td></tr>
<tr class="memdesc:a01bf98587a47624696aa808efac92ad8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Muestra en pantalla los nodos de frontera tipo Dirchlet.  <a href="#a01bf98587a47624696aa808efac92ad8">More...</a><br /></td></tr>
<tr class="separator:a01bf98587a47624696aa808efac92ad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a4f5148e80cc4a1df6db20e149515a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh.html#a0a4f5148e80cc4a1df6db20e149515a2">shownodeNeumman</a> ()</td></tr>
<tr class="memdesc:a0a4f5148e80cc4a1df6db20e149515a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Muestra en pantalla los nodos de frontera tipo Dirchlet.  <a href="#a0a4f5148e80cc4a1df6db20e149515a2">More...</a><br /></td></tr>
<tr class="separator:a0a4f5148e80cc4a1df6db20e149515a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeca4f92ea58c7c4f87e33df91ac33574"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh.html#aeca4f92ea58c7c4f87e33df91ac33574">showNeighborh</a> ()</td></tr>
<tr class="memdesc:aeca4f92ea58c7c4f87e33df91ac33574"><td class="mdescLeft">&#160;</td><td class="mdescRight">Muestra en pantalla los nodos vecinos de cada nodo.  <a href="#aeca4f92ea58c7c4f87e33df91ac33574">More...</a><br /></td></tr>
<tr class="separator:aeca4f92ea58c7c4f87e33df91ac33574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a941977c20a68f58aa11d264fb30f3032"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh.html#a941977c20a68f58aa11d264fb30f3032">showTotal</a> ()</td></tr>
<tr class="memdesc:a941977c20a68f58aa11d264fb30f3032"><td class="mdescLeft">&#160;</td><td class="mdescRight">Muestra en pantalla el numero total de nodos y de elementos de un dominio de interes.  <a href="#a941977c20a68f58aa11d264fb30f3032">More...</a><br /></td></tr>
<tr class="separator:a941977c20a68f58aa11d264fb30f3032"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Los objetos tipos mesh son contenedores para el dominio de interes generado con la herramienta gmsh. </p>
<dl class="section version"><dt>Version</dt><dd>1.0 </dd></dl>
<dl class="section date"><dt>Date</dt><dd>6/12/2016 </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Mario Arturo Nieto Butrón  SYSG </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a54a9cf0f6223e63253c8e9f8f99746b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54a9cf0f6223e63253c8e9f8f99746b3">&sect;&nbsp;</a></span>Mesh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Mesh::Mesh </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor para cargar un archivo &lt;nombre&gt;.msh y encargado de llamar a initialize(filename), para dar el tratamiento basico a una geometria obtenida con la herramienta gmsh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Ruta de un archivo &lt;nombre&gt;.msh para leer el dominio de trabajo.  vertices Vertices del dominio. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_mesh.html#afa6559daf1f8495fd0a796fb31370542">initialize</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a71e8935f4fb4b98e12aefb137ab15131"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71e8935f4fb4b98e12aefb137ab15131">&sect;&nbsp;</a></span>areaElement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mesh::areaElement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Para cada elemento triangular almacenado calcula su área según las coordenadas de sus vertices usando un determinantes, ésta área es almacenada en memoria para su uso. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ninguno</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="abe2ade2afc588a69ae7793eac37babfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe2ade2afc588a69ae7793eac37babfe">&sect;&nbsp;</a></span>bondaryCondition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mesh::bondaryCondition </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Para cada nodo de frontera se almacena en memoria el tipo de condición de frontera y su valor, solo acepta dos tipos distintos de condiciones de frontera Dirchelet y Neumman. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>Valor tipo int, recibe un 0 si se trata de un nodo tipo Dirichlet y 1 si se trata de un nodo tipo Neumman, en cualquier otro caso termina la ejecución. </td></tr>
    <tr><td class="paramname">value</td><td>Tipo double, recibe el valor de frontera de un nodo dado. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="a7860c41775b643917ea5e8d763ba0505"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7860c41775b643917ea5e8d763ba0505">&sect;&nbsp;</a></span>bordeNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt;&amp; Mesh::bordeNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Devuelve un vector con los nodos de frontera. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ninguno</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nodos de frontera </dd></dl>

</div>
</div>
<a id="a8da1c7918301eaf9f6c71979247d2d94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8da1c7918301eaf9f6c71979247d2d94">&sect;&nbsp;</a></span>borderInteriorNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mesh::borderInteriorNode </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Para un dominio rectangular determina que nodos se encuentran sobre la frontera, cuales son interiores y los almacena. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>Es un vector del tipo std::vector&lt;double&gt; y debe contener 4 los vertices de un dominio rectangular para hacer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="a7fcfd56c6f730879f51ff07153091f91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fcfd56c6f730879f51ff07153091f91">&sect;&nbsp;</a></span>coordX()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Mesh::coordX </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dado un nodo cualquiera de la malla devuelve su coordenada en x. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Identificador del nodo que se desea su coordenada x </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double valor entero con la coordenada x de un nodo dado </dd></dl>

</div>
</div>
<a id="af4f621b62849423e299f681acb4e253c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4f621b62849423e299f681acb4e253c">&sect;&nbsp;</a></span>coordY()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Mesh::coordY </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dado un nodo cualquiera de la malla devuelve su coordenada en y. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Identificador del nodo que se desea su coordenada y </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double valor entero con la coordenada y de un nodo dado </dd></dl>

</div>
</div>
<a id="a721990c561955657b21953ea704e4e6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a721990c561955657b21953ea704e4e6d">&sect;&nbsp;</a></span>elementSupportNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mesh::elementSupportNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Para cada nodo de la malla se calcula sus elementos soporte; es decir se almacena para cada nodo los elementos en donde aparace. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ninguno</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="add85351d5f09484fa3b4dd43d1043ae9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add85351d5f09484fa3b4dd43d1043ae9">&sect;&nbsp;</a></span>Incognite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt;&amp; Mesh::Incognite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Devuelve los nodos incognita. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ninguno</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;int&gt; Devuelve los nodos incognita. </dd></dl>

</div>
</div>
<a id="afa6559daf1f8495fd0a796fb31370542"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa6559daf1f8495fd0a796fb31370542">&sect;&nbsp;</a></span>initialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mesh::initialize </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Ruta de la localización de un archivo gmsh.  vertices Vertices del dominio. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abc68a06825b9554803c18248501338c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc68a06825b9554803c18248501338c7">&sect;&nbsp;</a></span>nNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Mesh::nNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Devuelve el numero total de nodos de una malla. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ninguno</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>_nnodes Numero total de nodos de la malla </dd></dl>

</div>
</div>
<a id="a53a4d94cd56d2cb6439519645269d380"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53a4d94cd56d2cb6439519645269d380">&sect;&nbsp;</a></span>nNodeIncongnite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Mesh::nNodeIncongnite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Devuelve el numero de nodos incognta que se tienen en la malla. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ninguno.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="a0acd89c6420f7edc3c8ee8169662b67b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0acd89c6420f7edc3c8ee8169662b67b">&sect;&nbsp;</a></span>nodeIncongnite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mesh::nodeIncongnite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Segun el tipo de cada nodo se determina que nodos son incognita y para que nodos se conoce la solución en ese punto, y son almacenados en memoria. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ninguno</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="a9f8707ebeb80eeca1d41ea67a56f7205"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f8707ebeb80eeca1d41ea67a56f7205">&sect;&nbsp;</a></span>nodeNeighborh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; Mesh::nodeNeighborh </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dado un nodo devuelve los nodos más proximos a el que lo rodean es decir sus nodos vecinos. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Identificador del nodo del que se desea conocer sus vecinos </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>un vector de tipo std::vector&lt;int&gt; que contiene los nodos vecinos </dd></dl>

</div>
</div>
<a id="ab798a46d1133887500152df4dfe40736"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab798a46d1133887500152df4dfe40736">&sect;&nbsp;</a></span>piP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; Mesh::piP </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::pair&lt; double, double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Se implementa el algoritmo PointInPolygon, el cual determina para un poligono convexo si un punto se encuentra en su interior o en su exterior. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>arreglo de tipo std::vector&lt;std::pair&lt;double,double&gt;&gt; almacena los vertices de un poligono convexo. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nodes regresa un arreglo de tipo std::vector&lt;int&gt; el cual indica que nodos están dentro del poligono. </dd></dl>

</div>
</div>
<a id="a0885d845bc4001d43d7d92a0a98a127a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0885d845bc4001d43d7d92a0a98a127a">&sect;&nbsp;</a></span>readFileGMSH()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mesh::readFileGMSH </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>coord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; int &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>elemn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lee un archivo *.msh generado con la herramienta gmsh y almacena las coordenadas y los elementos triangulares que lo conforman. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Ruta de la localización de un archivo gmsh. </td></tr>
    <tr><td class="paramname">coord</td><td>Matriz de tipo std::vector&lt;std::vector&lt;double&gt;&gt; para almacenar las coordenadas de cada nodo de la malla segun la numeracion por gmsh. </td></tr>
    <tr><td class="paramname">elemn</td><td>Matriz de tipo std::vector&lt;std::vector&lt;int&gt;&gt; para almacenar los elementos triangulares y su nodos que lo conforman segun la numeración de gmsh. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="a88e3d635b654e3122774b3e49770648e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88e3d635b654e3122774b3e49770648e">&sect;&nbsp;</a></span>relationNodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mesh::relationNodes </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>coord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>relation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Toma los nodos ordenados y los desordenados y devuelve una relacion entre ellos, donde el indice de relation se refiere a la numeración de gmsh y el contenido indica a que lugar se movio en los nodos. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Recibe</td><td>una matriz de la forma std::vector&lt;std::vector&lt;double&gt;&gt; que debera contener las coordenada X y Y de cada nodo de la malla </td></tr>
    <tr><td class="paramname"><a class="el" href="class_vector.html" title="Clase para dar tratamiento a los vectores. ">Vector</a></td><td>de tipo std::vector&lt;int&gt;, en donde será almacenada temporalmente la relacion entre la numeración de gmsh y la numeración de los nodos ordenados. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="a7972a36435ea43732b4611a3765c28f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7972a36435ea43732b4611a3765c28f6">&sect;&nbsp;</a></span>reorderElement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mesh::reorderElement </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; int &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>elemn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>relation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Se reordenan los elementos segun la nueva numeracion de los nodos. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elemn</td><td><a class="el" href="class_vector.html" title="Clase para dar tratamiento a los vectores. ">Vector</a> del tipo std::vector&lt;int&gt;&gt; que contiene cada elemento y los nodos que contiene </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="a1a49aea1d3aa8ccf4f8acd367906b4ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a49aea1d3aa8ccf4f8acd367906b4ab">&sect;&nbsp;</a></span>reorderNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mesh::reorderNode </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>coord</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Toma los nodos leidos del archivo y cambia el orden dado por GMSH, ordena primero con respecto a Y y despues con respecto a X de forma tal que se tendra todos los nodos con la misma componente en Y y despues se ordena las x en forma asecendente. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coord</td><td>Recibe una matriz de la forma std::vector&lt;std::vector&lt;double&gt;&gt; que debera contener las coordenada X y Y de cada nodo de la malla </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="a759b0e82f01de4d168b2a30e5280df3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a759b0e82f01de4d168b2a30e5280df3c">&sect;&nbsp;</a></span>showArea()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mesh::showArea </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Muestra en pantalla el area de cada elemento triangular que fue calculado. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ninguno</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="a45a42ffc6565851e50e47b6b618c22f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45a42ffc6565851e50e47b6b618c22f5">&sect;&nbsp;</a></span>showBoundaryCondition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mesh::showBoundaryCondition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Muestra en pantalla los nodos frontera con su valor asignado y de que tipo son. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ninguno</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="a0d528aac55b1e4c2a6f5049f9d2cf90d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d528aac55b1e4c2a6f5049f9d2cf90d">&sect;&nbsp;</a></span>showElement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mesh::showElement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Muestra en pantalla la nueva composición de los elementos según la nueva numeración. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ninguno</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="a895299dd6c9c2e2ffb5ef59becc81fd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a895299dd6c9c2e2ffb5ef59becc81fd3">&sect;&nbsp;</a></span>showElementSupportNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mesh::showElementSupportNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mostramos en pantalla los elementos soporte de cada nodo. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ninguno.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ab390b1e1292e0236b1a3d35c6b738228"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab390b1e1292e0236b1a3d35c6b738228">&sect;&nbsp;</a></span>showGmsh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mesh::showGmsh </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>coord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; int &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>elemn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Muestra en pantalla los nodos y los elementos leidos del archivo gmsh segun la numeracion por defecto. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coord</td><td>Matriz de tipo std::vector&lt;std::vector&lt;double&gt;&gt; que contiene las coordenadas de cada nodo de la malla. </td></tr>
    <tr><td class="paramname">elemn</td><td>Matriz de tipo std::vector&lt;std::vector&lt;int&gt;&gt; que contiene los elementos y los nodos que lo conforman. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="aeca4f92ea58c7c4f87e33df91ac33574"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeca4f92ea58c7c4f87e33df91ac33574">&sect;&nbsp;</a></span>showNeighborh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mesh::showNeighborh </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Muestra en pantalla los nodos vecinos de cada nodo. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ninguno</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ac5eb1247da3ed432323f1dd8aebbf554"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5eb1247da3ed432323f1dd8aebbf554">&sect;&nbsp;</a></span>showNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mesh::showNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Muestra en pantalla los nodos con sus coordenadas ordenados. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ninguno</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="a01bf98587a47624696aa808efac92ad8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01bf98587a47624696aa808efac92ad8">&sect;&nbsp;</a></span>shownodeDirichlet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mesh::shownodeDirichlet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Muestra en pantalla los nodos de frontera tipo Dirchlet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ninguno</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ac8d60f17c950dca8ef1a6288860bd3cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8d60f17c950dca8ef1a6288860bd3cb">&sect;&nbsp;</a></span>showNodeElement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mesh::showNodeElement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Muestra en pantalla la cantidad de nodos y elementos totales de la malla. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ninguno</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="a4de5c225341eb4fc73810d1415eb57da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4de5c225341eb4fc73810d1415eb57da">&sect;&nbsp;</a></span>showNodeIF()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mesh::showNodeIF </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Muestra en pantalla que nodos son interiores y que nodos son frontera. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ninguno.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="a0a4f5148e80cc4a1df6db20e149515a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a4f5148e80cc4a1df6db20e149515a2">&sect;&nbsp;</a></span>shownodeNeumman()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mesh::shownodeNeumman </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Muestra en pantalla los nodos de frontera tipo Dirchlet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ninguno</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="a90fd6f1f7a64ff29d1eeee72c22142d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90fd6f1f7a64ff29d1eeee72c22142d2">&sect;&nbsp;</a></span>showRelation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mesh::showRelation </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>relation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mostramos en pantalla la relacion de la numeración ordenada con la numeración de gmsh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ninguno</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="a941977c20a68f58aa11d264fb30f3032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a941977c20a68f58aa11d264fb30f3032">&sect;&nbsp;</a></span>showTotal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mesh::showTotal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Muestra en pantalla el numero total de nodos y de elementos de un dominio de interes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ninguno</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="aef283d305e17ab48771999e7835ed294"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef283d305e17ab48771999e7835ed294">&sect;&nbsp;</a></span>type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Mesh::type </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dado un nodo frontera devuelve su tipo. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Recibe un identificador de nodo de frontera. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>devuelve 0 si es Dirichlet y 1 si es Neumman </dd></dl>

</div>
</div>
<a id="a1e306db2532f24a66b8d43cb634afd61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e306db2532f24a66b8d43cb634afd61">&sect;&nbsp;</a></span>typeNodeBorder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mesh::typeNodeBorder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Distingue los nodos de frontera en nodos tipo Dirichlet y nodos tipo Neumann. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ninguno</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="adef108df36f29f4880a9233075e04210"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adef108df36f29f4880a9233075e04210">&sect;&nbsp;</a></span>value()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Mesh::value </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dado un nodo frontera devuelve su valor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Recibe un identificador de nodo de frontera. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>valor de la condición de frontera de un nodo. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/Users/m0nT3cR1s70/Dropbox/Tesis/Codigo/C++/Validate/<a class="el" href="_mesh_8hpp_source.html">Mesh.hpp</a></li>
<li>/Users/m0nT3cR1s70/Dropbox/Tesis/Codigo/C++/Validate/Mesh.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.12
</small></address>
</body>
</html>
